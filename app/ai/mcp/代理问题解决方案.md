# MCP 客户端代理问题解决方案

## 🐛 问题描述

### 错误现象

```
2025-12-31 16:55:38 | DEBUG | connect_tcp.started host='127.0.0.1' port=10808
2025-12-31 16:55:38 | DEBUG | connect_tcp.failed exception=ConnectError(OSError('All connection attempts failed'))
2025-12-31 16:55:38 | ERROR | [fastmcp-demo-tools] ❌ 初始化客户端失败: Client is not connected
```

### 问题分析

1. **MCP Server** 启动在 `127.0.0.1:8008` ✅
2. **客户端连接** 却尝试连接到 `127.0.0.1:10808` ❌
3. **根本原因**: 系统设置了 HTTP 代理（端口 10808），`httpx` 客户端自动使用了代理

### 为什么会出现代理拦截？

```
客户端 → 代理(10808) → MCP Server(8008)
        ❌ 代理无法理解 MCP 协议
```

- `fastmcp.Client` 内部使用 `httpx.AsyncClient`
- `httpx` 会自动读取系统代理环境变量：
  - `HTTP_PROXY`
  - `HTTPS_PROXY`
  - `http_proxy`
  - `https_proxy`
  - `ALL_PROXY`
  - `all_proxy`
- 本地 MCP Server 连接不需要代理，应该直连

## ✅ 解决方案

### 核心思路

**多层防护禁用代理：环境变量 + NO_PROXY + Monkey Patch httpx**

macOS 系统代理设置优先级很高，即使清除环境变量也会被 httpx 读取。因此需要：
1. 清除代理环境变量（HTTP_PROXY, HTTPS_PROXY 等）
2. 设置 NO_PROXY 绕过列表
3. **Monkey Patch httpx.AsyncClient，强制 trust_env=False**

### 实现方式

#### 1. 在 `client_manager.py` 中禁用代理（第一层防护）

```python
async def init_mcp_clients(self) -> bool:
    # 保存并清除代理环境变量
    import os
    old_proxies = {}
    proxy_keys = ['HTTP_PROXY', 'HTTPS_PROXY', 'http_proxy', 'https_proxy', 
                  'ALL_PROXY', 'all_proxy', 'NO_PROXY', 'no_proxy']
    
    # 保存原始设置
    for key in proxy_keys:
        if key in os.environ:
            old_proxies[key] = os.environ[key]
    
    # 清除所有代理环境变量
    for key in ['HTTP_PROXY', 'HTTPS_PROXY', 'http_proxy', 'https_proxy', 
                'ALL_PROXY', 'all_proxy']:
        if key in os.environ:
            del os.environ[key]
    
    # 🔥 关键：设置 NO_PROXY 绕过系统代理（macOS）
    os.environ['NO_PROXY'] = 'localhost,127.0.0.1,0.0.0.0,::1,.local'
    os.environ['no_proxy'] = 'localhost,127.0.0.1,0.0.0.0,::1,.local'
    
    if old_proxies:
        logger.info("🚫 已临时禁用系统代理（避免本地MCP连接失败）")
        logger.debug(f"设置 NO_PROXY: {os.environ['NO_PROXY']}")
    
    try:
        # 初始化所有 MCP 客户端...
        ...
        return success_count > 0
        
    finally:
        # 恢复代理设置
        for key, value in old_proxies.items():
            os.environ[key] = value
        
        if old_proxies:
            logger.debug("✅ 已恢复系统代理设置")
```

#### 2. 在 `fastmcp_client.py` 中 Monkey Patch httpx（第二层防护）

```python
async def _init_http_client(self):
    """初始化HTTP传输客户端"""
    base_url = self.config.get("url", "http://127.0.0.1:8000/mcp")
    
    # 确保URL以/结尾
    if not base_url.endswith('/'):
        base_url += '/'
    
    logger.info(f"[{self.name}] 📡 连接HTTP服务: {base_url}")
    logger.debug(
        f"[{self.name}] 当前环境: "
        f"HTTP_PROXY={os.environ.get('HTTP_PROXY', 'None')}, "
        f"NO_PROXY={os.environ.get('NO_PROXY', 'None')}"
    )
    
    # 🔥 关键：Monkey patch httpx 强制禁用代理
    import httpx
    
    # 保存原始的 Client 类
    original_client = httpx.AsyncClient
    
    # 创建包装器，强制禁用代理
    class NoProxyAsyncClient(original_client):
        def __init__(self, *args, **kwargs):
            # trust_env=False: 忽略环境变量和系统代理
            kwargs['trust_env'] = False
            kwargs.setdefault('proxies', None)
            super().__init__(*args, **kwargs)
    
    # 临时替换 httpx.AsyncClient
    httpx.AsyncClient = NoProxyAsyncClient
    
    try:
        # 创建HTTP传输并连接（fastmcp.Client 内部会使用我们的 NoProxyAsyncClient）
        self.client = await self.exit_stack.enter_async_context(
            Client(base_url)
        )
        logger.debug(f"[{self.name}] ✅ HTTP客户端创建成功（已禁用代理）")
        
    finally:
        # 恢复原始的 httpx.AsyncClient
        httpx.AsyncClient = original_client
```

**为什么需要 Monkey Patch？**

- `fastmcp.Client` 不提供传入自定义 httpx 客户端的接口
- httpx 默认 `trust_env=True`，会读取系统代理设置
- macOS 系统代理优先级高，即使清除环境变量也会被读取
- **Monkey Patch 是唯一能强制禁用系统代理的方法**

### 为什么在 `client_manager` 层面处理？

✅ **优势：**
1. **集中管理**: 所有客户端统一处理，不需要每个客户端单独处理
2. **作用域清晰**: try-finally 确保代理设置一定会恢复
3. **线程安全**: 在异步初始化期间整体禁用，避免竞争条件
4. **代码简洁**: 不需要在每个传输类型中重复代码

❌ **如果在 `fastmcp_client` 处理的问题：**
1. 需要在 `_init_http_client` 和 `_init_stdio_client` 中重复代码
2. try-finally 嵌套复杂
3. 环境变量修改不是线程安全的

## 📊 工作流程

```
启动应用
    ↓
检测到系统代理 (HTTP_PROXY=http://127.0.0.1:10808)
    ↓
临时清除所有代理环境变量
    ↓
初始化 MCP 客户端
    ├─ fastmcp-demo-tools (直连 127.0.0.1:8008) ✅
    ├─ windows-cli (直连 npx 命令) ✅
    └─ ... (其他 MCP 服务)
    ↓
恢复原始代理设置
    ↓
正常使用（外部 API 调用可以继续使用代理）
```

## 🔧 修改的文件

| 文件 | 修改内容 | 重要性 |
|------|---------|--------|
| `client_manager.py` | ✅ 清除代理环境变量 | 🔥 |
| `client_manager.py` | ✅ 设置 NO_PROXY 绕过列表 | 🔥 |
| `client_manager.py` | ✅ try-finally 确保恢复 | ✅ |
| `fastmcp_client.py` | 🔥 Monkey Patch httpx.AsyncClient | 🔥🔥🔥 |
| `fastmcp_client.py` | 🔥 强制 trust_env=False | 🔥🔥🔥 |
| `fastmcp_client.py` | ✅ 增强日志输出 | ✅ |
| `server_manager.py` | ✅ 端口占用检查和清理 | ✅ |

### 修复层级（重要到最重要）

1. ⭐ **清除环境变量**：基础防护
2. ⭐⭐ **设置 NO_PROXY**：绕过系统代理列表
3. ⭐⭐⭐ **Monkey Patch httpx**：🔥 **核心解决方案**，强制禁用 trust_env

## 🧪 测试验证

### 测试步骤 1: 有代理环境

```bash
# 1. 设置代理（模拟生产环境）
export HTTP_PROXY=http://127.0.0.1:10808
export HTTPS_PROXY=http://127.0.0.1:10808

# 2. 启动应用
python run_app.py
```

**期望日志：**
```
🚫 已临时禁用系统代理（避免本地MCP连接失败）
设置 NO_PROXY: localhost,127.0.0.1,0.0.0.0,::1,.local
📡 正在初始化MCP服务: fastmcp-demo-tools
[fastmcp-demo-tools] 📡 连接HTTP服务: http://127.0.0.1:8008/mcp/
[fastmcp-demo-tools] 当前环境: HTTP_PROXY=None, HTTPS_PROXY=None, NO_PROXY=localhost,127.0.0.1,0.0.0.0,::1,.local
[fastmcp-demo-tools] ✅ HTTP客户端创建成功（已禁用代理）
[fastmcp-demo-tools] ✅ 客户端初始化成功 - 工具数量: 3
✅ 服务 fastmcp-demo-tools 初始化成功，获取到 3 个工具
✅ 已恢复系统代理设置
```

**关键检查点：**
- ✅ `connect_tcp.started host='127.0.0.1' port=8008`（而不是 10808）
- ✅ `NO_PROXY` 已设置
- ✅ `HTTP客户端创建成功（已禁用代理）`

### 测试步骤 2: 无代理环境

```bash
# 1. 清除代理
unset HTTP_PROXY HTTPS_PROXY http_proxy https_proxy

# 2. 启动应用
python run_app.py
```

**期望日志：**
```
📡 正在初始化MCP服务: fastmcp-demo-tools
[fastmcp-demo-tools] 📡 连接HTTP服务: http://127.0.0.1:8008/mcp
[fastmcp-demo-tools] 当前代理设置: HTTP_PROXY=None, HTTPS_PROXY=None
✅ 服务 fastmcp-demo-tools 初始化成功，获取到 3 个工具
```

### 测试步骤 3: 桌面应用

```bash
# 1. 打包
python build_desktop.py

# 2. 启动（系统有代理）
open dist/wx公众号工具.app
```

**期望行为：**
- MCP Server 启动成功
- MCP 客户端连接成功
- AI 助手可以正常调用工具

## 🔍 调试技巧

### 如何确认是代理问题？

查看日志中的连接端口：

```python
# ❌ 错误 - 连接到代理端口
connect_tcp.started host='127.0.0.1' port=10808  # 10808 是代理端口

# ✅ 正确 - 直连 MCP Server
connect_tcp.started host='127.0.0.1' port=8008   # 8008 是 MCP Server 端口
```

### 手动测试连接

```bash
# 测试 1: 有代理时（会失败）
export HTTP_PROXY=http://127.0.0.1:10808
curl http://127.0.0.1:8008/mcp

# 测试 2: 无代理时（应该成功）
unset HTTP_PROXY HTTPS_PROXY
curl http://127.0.0.1:8008/mcp
```

### 查看当前代理设置

```bash
# macOS/Linux
env | grep -i proxy

# Python 中
import os
print(os.environ.get('HTTP_PROXY'))
print(os.environ.get('HTTPS_PROXY'))
```

## 🚨 常见问题

### Q1: 为什么不在 httpx 层面禁用代理？

**A:** `fastmcp.Client` 没有提供直接配置 `httpx` 的接口，我们无法传入自定义的 `httpx.AsyncClient(proxies=None)`。

### Q2: 修改环境变量是否安全？

**A:** 
- ✅ 在 `async def` 中修改是安全的（单进程单事件循环）
- ✅ 使用 try-finally 确保一定会恢复
- ⚠️  如果有多线程/多进程同时修改环境变量，可能有竞争条件

### Q3: 会影响其他需要代理的请求吗？

**A:** 不会。
- 只在 MCP 客户端初始化期间禁用（约 2-5 秒）
- 初始化完成后立即恢复
- AI 调用外部 API（如 OpenAI）时代理已恢复

### Q4: 如果 MCP Server 在远程服务器上呢？

**A:** 如果 MCP Server 不在本地，需要修改方案：

```python
# 方案：只对本地地址禁用代理
def should_use_proxy(url: str) -> bool:
    """判断是否应该使用代理"""
    from urllib.parse import urlparse
    host = urlparse(url).hostname
    
    # 本地地址不使用代理
    local_hosts = ['localhost', '127.0.0.1', '0.0.0.0', '::1']
    return host not in local_hosts

# 在初始化时判断
if not should_use_proxy(base_url):
    # 禁用代理
    ...
```

### Q5: 如果用户手动配置了 `~/.curlrc` 或 `~/.wgetrc` 中的代理？

**A:** 环境变量优先级更高，修改环境变量可以覆盖这些配置文件。

## 📝 最佳实践

### 1. 本地服务应该直连

```python
# ✅ 推荐：本地服务不走代理
LOCAL_MCP_URLS = [
    "http://127.0.0.1:8008/mcp",
    "http://localhost:8008/mcp"
]

# ❌ 不推荐：本地服务也走代理（会增加延迟和失败风险）
```

### 2. 临时禁用代理的最小化原则

```python
# ✅ 只在必要时禁用
try:
    disable_proxy()
    connect_to_local_service()
finally:
    restore_proxy()

# ❌ 全局永久禁用（会影响其他网络请求）
del os.environ['HTTP_PROXY']  # 没有恢复
```

### 3. 日志记录

```python
# ✅ 记录代理状态变化
logger.info("🚫 已临时禁用系统代理")
logger.debug(f"当前代理: {os.environ.get('HTTP_PROXY', 'None')}")
logger.debug("✅ 已恢复系统代理设置")
```

### 4. 配置文件支持

可以在配置文件中添加选项：

```json
{
  "mcpServer": {
    "fastmcp-demo-tools": {
      "url": "http://127.0.0.1:8008/mcp",
      "transport": "streamable-http",
      "use_proxy": false  // 是否使用代理
    }
  }
}
```

## ✨ 总结

### 问题
- 🐛 macOS 系统代理拦截了本地 MCP 连接
- 🐛 即使清除环境变量，httpx 仍读取系统代理配置
- 🐛 客户端尝试连接代理端口 10808 而非 MCP Server 端口 8008

### 解决（多层防护）
1. ✅ 清除代理环境变量（HTTP_PROXY, HTTPS_PROXY 等）
2. ✅ 设置 NO_PROXY 绕过列表（localhost, 127.0.0.1 等）
3. 🔥 **Monkey Patch httpx.AsyncClient，强制 trust_env=False**
4. ✅ try-finally 确保代理设置一定恢复

### 效果
- 开发环境：✅ 有/无代理都能正常连接
- 系统代理：✅ macOS 系统代理不再干扰
- 打包环境：✅ 桌面应用正常工作
- 用户体验：✅ 透明处理，无需手动配置

### 技术亮点
1. **多层防护**: 环境变量 + NO_PROXY + Monkey Patch，确保万无一失
2. **最小化影响**: 只在初始化期间禁用，不影响后续请求
3. **安全恢复**: try-finally 确保代理设置一定恢复
4. **智能 Patch**: 临时替换 httpx.AsyncClient，不影响全局
5. **向后兼容**: 不影响远程 MCP Server 的场景

### 核心创新
🔥 **Monkey Patch httpx.AsyncClient** - 这是解决 macOS 系统代理问题的**唯一有效方法**

```python
# 🔥 关键代码
class NoProxyAsyncClient(httpx.AsyncClient):
    def __init__(self, *args, **kwargs):
        kwargs['trust_env'] = False  # 忽略系统代理
        kwargs.setdefault('proxies', None)
        super().__init__(*args, **kwargs)

httpx.AsyncClient = NoProxyAsyncClient  # 临时替换
```

---

**修复日期：** 2025-12-31  
**问题类型：** macOS 系统代理拦截本地连接  
**影响范围：** MCP 客户端初始化流程  
**解决方案：** 多层防护（环境变量 + NO_PROXY + Monkey Patch httpx）  
**核心技术：** 🔥 Monkey Patch httpx.AsyncClient 强制 trust_env=False

